#!/bin/bash
set -euo pipefail

# Workato SDK Documentation Helper Script v1.0
# This script handles all /workato-sdk command functionality  
# Installation path: ~/.workato-sdk-docs/workato-sdk-helper.sh

# Script version
SCRIPT_VERSION="1.0"

# Fixed installation path
DOCS_PATH="$HOME/.workato-sdk-docs"
MANIFEST="$DOCS_PATH/docs/docs_manifest.json"

# Enhanced sanitize function to prevent command injection
sanitize_input() {
    # Remove ALL shell metacharacters and control characters
    echo "$1" | sed 's/[^a-zA-Z0-9 _.,'\''?-]//g' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//'
}

# Function to print documentation header
print_doc_header() {
    echo "ðŸ“š WORKATO SDK DOCS MIRROR: https://github.com/kreitter/workato-sdk-docs"
    echo "ðŸ“– OFFICIAL DOCS: https://docs.workato.com/en/developing-connectors/sdk.html"
    echo ""
}

# Function to auto-update docs if needed
auto_update() {
    cd "$DOCS_PATH" 2>/dev/null || return 1

    # Get current branch
    local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")

    # Quick fetch to check for updates
    if ! git fetch --quiet origin "$BRANCH" 2>/dev/null; then
        if ! git fetch --quiet origin main 2>/dev/null; then
            return 2
        fi
        BRANCH="main"
    fi

    local LOCAL=$(git rev-parse HEAD 2>/dev/null)
    local REMOTE=$(git rev-parse origin/"$BRANCH" 2>/dev/null)
    local BEHIND=$(git rev-list HEAD..origin/"$BRANCH" --count 2>/dev/null || echo "0")

    if [[ "$LOCAL" != "$REMOTE" ]] && [[ "$BEHIND" -gt 0 ]]; then
        echo "ðŸ”„ Updating SDK documentation..." >&2
        git pull --quiet origin "$BRANCH" 2>&1 | grep -v "Merge made by" || true

        # Check if installer needs updating
        if [[ -f "./install.sh" ]]; then
            echo "ðŸ”§ Updating Workato SDK Docs installer..." >&2
            ./install.sh >/dev/null 2>&1
        fi
    fi

    # Auto-commit and push timestamp-only changes
    auto_commit_timestamps

    return 0
}

# Function to auto-commit and push documentation changes
auto_commit_timestamps() {
    cd "$DOCS_PATH" 2>/dev/null || return 1

    # Check if there are any changes
    if git diff --quiet && git diff --cached --quiet; then
        return 0  # No changes to commit
    fi

    # Check if ALL changes are only in docs directory
    local non_doc_changes=$(git diff --name-only | grep -v "^docs/" || true)
    if [[ -n "$non_doc_changes" ]]; then
        return 0  # There are changes outside of docs directory
    fi

    # At this point, all changes are in the docs directory
    echo "ðŸ“ Auto-committing SDK documentation updates..." >&2

    # Stage all the doc changes
    git add docs/ 2>/dev/null || true

    # Determine the type of changes for the commit message
    local has_content_changes=0
    local changed_files_count=$(git diff --cached --name-only | wc -l | tr -d ' ')

    # Check if there are content changes (not just timestamps)
    while IFS= read -r file; do
        if [[ "$file" == docs/*.md ]]; then
            local diff_lines=$(git diff --cached "$file" | grep "^[+-]" | grep -v "^[+-][+-][+-]" | grep -v "^[+-]> \*\*Fetched\*\*:" || true)
            if [[ -n "$diff_lines" ]]; then
                has_content_changes=1
                break
            fi
        fi
    done < <(git diff --cached --name-only)

    # Create appropriate commit message
    local commit_date=$(date +"%Y-%m-%d %H:%M")
    local commit_message=""

    if [[ $has_content_changes -eq 1 ]]; then
        commit_message="Update SDK docs - content and timestamps - $commit_date

Auto-generated commit: Documentation content and metadata updated from Workato"
    else
        commit_message="Update SDK docs timestamps - $commit_date

Auto-generated commit: Documentation fetch timestamps updated"
    fi

    git commit -m "$commit_message" >/dev/null 2>&1

    # Push to origin
    echo "ðŸ“¤ Pushing documentation updates to origin..." >&2
    if git push origin HEAD >/dev/null 2>&1; then
        echo "âœ… Documentation updates pushed successfully" >&2
    else
        echo "âš ï¸  Could not push updates (may need authentication)" >&2
    fi
}

# Function to show documentation sync status
show_freshness() {
    print_doc_header
    
    # Read manifest
    if [[ ! -f "$MANIFEST" ]]; then
        echo "âŒ Error: SDK documentation not found at ~/.workato-sdk-docs"
        echo "Please install with:"
        echo "curl -fsSL https://raw.githubusercontent.com/kreitter/workato-sdk-docs/main/install.sh | bash"
        exit 1
    fi
    
    # Try to sync with GitHub
    auto_update
    local sync_status=$?
    
    if [[ $sync_status -eq 2 ]]; then
        echo "âš ï¸  Could not sync with GitHub (using local cache)"
        echo "Check your internet connection or GitHub access"
    else
        cd "$DOCS_PATH" 2>/dev/null || exit 1
        local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
        local COMPARE_BRANCH="$BRANCH"
        if ! git rev-parse --verify origin/"$BRANCH" >/dev/null 2>&1; then
            COMPARE_BRANCH="main"
        fi
        local AHEAD=$(git rev-list origin/"$COMPARE_BRANCH"..HEAD --count 2>/dev/null || echo "0")
        local BEHIND=$(git rev-list HEAD..origin/"$COMPARE_BRANCH" --count 2>/dev/null || echo "0")
        
        if [[ "$AHEAD" -gt 0 ]]; then
            echo "âš ï¸  Local version is ahead of GitHub by $AHEAD commit(s)"
        elif [[ "$BEHIND" -gt 0 ]]; then
            echo "âš ï¸  Local version is behind GitHub by $BEHIND commit(s)"
        else
            echo "âœ… You have the latest SDK documentation"
        fi
    fi
    
    # Show current branch and version
    cd "$DOCS_PATH" 2>/dev/null || exit 1
    local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    echo "ðŸ“ Branch: ${BRANCH}"
    echo "ðŸ“¦ Version: ${SCRIPT_VERSION}"
    
    # Show last fetch time from manifest
    if command -v jq >/dev/null 2>&1; then
        local LAST_FETCH=$(jq -r '.fetch_metadata.last_fetch_completed // "unknown"' "$MANIFEST" 2>/dev/null)
        echo "ðŸ•’ Last fetched: ${LAST_FETCH}"
    fi
}

# Function to read documentation
read_doc() {
    local topic=$(sanitize_input "$1")
    
    # Strip .md extension if user included it
    topic="${topic%.md}"
    
    local doc_path="$DOCS_PATH/docs/${topic}.md"
    
    if [[ -f "$doc_path" ]]; then
        print_doc_header
        
        # Quick check if we're up to date
        cd "$DOCS_PATH" 2>/dev/null || exit 1
        local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
        local VERSION=$SCRIPT_VERSION
        
        # Do the fetch to check status
        local COMPARE_BRANCH="$BRANCH"
        if ! git fetch --quiet origin "$BRANCH" 2>/dev/null; then
            if git fetch --quiet origin main 2>/dev/null; then
                COMPARE_BRANCH="main"
            else
                echo "âš ï¸  Could not check GitHub for updates - using cached docs (v$VERSION, $BRANCH)"
                echo ""
                cat "$doc_path"
                echo ""
                echo "ðŸ“– Official page: https://docs.workato.com/en/developing-connectors/sdk/${topic}.html"
                return
            fi
        fi
        
        local LOCAL=$(git rev-parse HEAD 2>/dev/null)
        local REMOTE=$(git rev-parse origin/"$COMPARE_BRANCH" 2>/dev/null)
        local BEHIND=$(git rev-list HEAD..origin/"$COMPARE_BRANCH" --count 2>/dev/null || echo "0")
        
        if [[ "$LOCAL" != "$REMOTE" ]] && [[ "$BEHIND" -gt 0 ]]; then
            echo "ðŸ”„ Updating to latest SDK documentation..."
            git pull --quiet origin "$COMPARE_BRANCH" 2>&1 | grep -v "Merge made by" || true

            if [[ -f "./install.sh" ]]; then
                ./install.sh >/dev/null 2>&1
            fi

            # Auto-commit timestamp changes after update
            auto_commit_timestamps

            echo "âœ… Updated to latest (v$VERSION, $BRANCH)"
        else
            local AHEAD=$(git rev-list origin/"$COMPARE_BRANCH"..HEAD --count 2>/dev/null || echo "0")
            if [[ "$AHEAD" -gt 0 ]]; then
                echo "âš ï¸  Using local development version (v$VERSION, $BRANCH, +$AHEAD commits)"
            else
                echo "âœ… You have the latest SDK docs (v$VERSION, $BRANCH)"
            fi
        fi
        echo ""
        
        cat "$doc_path"
        echo ""
        echo "ðŸ“– Official page: https://docs.workato.com/en/developing-connectors/sdk/${topic}.html"
    else
        # Show search interface
        print_doc_header
        echo "ðŸ” Searching for: $topic"
        echo ""
        
        # Try to extract keywords from the topic
        local keywords=$(echo "$topic" | grep -o '[a-zA-Z0-9_-]\+' | grep -v -E '^(tell|me|about|explain|what|is|are|how|do|to|show|find|search|the|for|in)$' | tr '\n' ' ')
        
        if [[ -n "$keywords" ]]; then
            # Search for matching topics
            local escaped_keywords=$(echo "$keywords" | sed 's/[[\.*^$()+?{|]/\\&/g')
            local matches=$(ls "$DOCS_PATH/docs" 2>/dev/null | grep '\.md$' | sed 's/\.md$//' | grep -i -E "$(echo "$escaped_keywords" | tr ' ' '|')" | sort)
            
            if [[ -n "$matches" ]]; then
                echo "Found these related SDK topics:"
                echo "$matches" | sed 's/^/  â€¢ /' 
                echo ""
                echo "Try: /workato-sdk <topic> to read a specific document"
            else
                echo "No exact matches found. Here are all available SDK topics:"
                ls "$DOCS_PATH/docs" 2>/dev/null | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
            fi
        else
            echo "Available SDK topics:"
            ls "$DOCS_PATH/docs" 2>/dev/null | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
        fi
        echo ""
        echo "ðŸ’¡ Tip: Use grep to search across all SDK docs: cd ~/.workato-sdk-docs && grep -r 'search term' docs/"
    fi
}

# Function to list available documentation
list_docs() {
    print_doc_header
    
    # Auto-update to ensure fresh list
    auto_update
    
    echo "Available Workato SDK documentation topics:"
    echo ""
    ls "$DOCS_PATH/docs" 2>/dev/null | grep '\.md$' | sed 's/\.md$//' | sort | column -c 80
    echo ""
    echo "Usage: /workato-sdk <topic> or /workato-sdk -t to check freshness"
}

# Function for hook check (auto-update)
hook_check() {
    exit 0
}

# Function to show what's new
whats_new() {
    set +e
    
    print_doc_header
    
    # Auto-update first
    auto_update || true
    
    cd "$DOCS_PATH" 2>/dev/null || {
        echo "âŒ Error: Could not access documentation directory"
        return 1
    }
    
    echo "ðŸ“š Recent SDK documentation updates:"
    echo ""
    
    # Get recent commits
    local count=0
    
    while IFS= read -r commit_line && [[ $count -lt 5 ]]; do
        local hash=$(echo "$commit_line" | cut -d' ' -f1)
        local date=$(git show -s --format=%cr "$hash" 2>/dev/null || echo "unknown")
        
        echo "â€¢ $date:"
        echo "  ðŸ“Ž https://github.com/kreitter/workato-sdk-docs/commit/$hash"
        
        # Show which docs changed
        local changed_docs=$(git diff-tree --no-commit-id --name-only -r "$hash" -- docs/*.md 2>/dev/null | sed 's|docs/||' | sed 's|\.md$||' | head -5)
        if [[ -n "$changed_docs" ]]; then
            echo "$changed_docs" | while read -r doc; do
                [[ -n "$doc" ]] && echo "  ðŸ“„ $doc"
            done
        fi
        echo ""
        ((count++))
    done < <(git log --oneline -10 -- docs/*.md 2>/dev/null | grep -v "Merge" || true)
    
    if [[ $count -eq 0 ]]; then
        echo "No recent SDK documentation updates found."
        echo ""
    fi
    
    echo "ðŸ“Ž Full changelog: https://github.com/kreitter/workato-sdk-docs/commits/main/docs"
    
    set -e
    return 0
}

# Function for uninstall
uninstall() {
    print_doc_header
    echo "To uninstall Workato SDK Documentation Mirror"
    echo "============================================"
    echo ""
    
    echo "This will remove:"
    echo "  â€¢ The /workato-sdk command from ~/.claude/commands/workato-sdk.md"
    echo "  â€¢ The auto-update hook from ~/.claude/settings.json"
    echo "  â€¢ The installation directory ~/.workato-sdk-docs"
    echo ""
    
    echo "Run this command in your terminal:"
    echo ""
    echo "  ~/.workato-sdk-docs/uninstall.sh"
    echo ""
    echo "Or to skip confirmation:"
    echo "  echo 'y' | ~/.workato-sdk-docs/uninstall.sh"
    echo ""
}

# Store original arguments for flag checking
FULL_ARGS="$*"

# Check if arguments start with -t flag
if [[ "$FULL_ARGS" =~ ^-t([[:space:]]+(.*))?$ ]]; then
    show_freshness
    remaining_args="${BASH_REMATCH[2]}"
    if [[ "$remaining_args" =~ ^what.?s?[[:space:]]?new.*$ ]]; then
        echo ""
        whats_new
    elif [[ -n "$remaining_args" ]]; then
        echo ""
        read_doc "$(sanitize_input "$remaining_args")"
    fi
    exit 0
elif [[ "$FULL_ARGS" =~ ^--check([[:space:]]+(.*))?$ ]]; then
    show_freshness
    remaining_args="${BASH_REMATCH[2]}"
    if [[ "$remaining_args" =~ ^what.?s?[[:space:]]?new.*$ ]]; then
        echo ""
        whats_new
    elif [[ -n "$remaining_args" ]]; then
        echo ""
        read_doc "$(sanitize_input "$remaining_args")"
    fi
    exit 0
fi

# Main command handling
case "${1:-}" in
    -t|--check)
        show_freshness
        shift
        remaining_args="$*"
        if [[ "$remaining_args" =~ ^what.?s?[[:space:]]?new.*$ ]]; then
            echo ""
            whats_new
        elif [[ -n "$remaining_args" ]]; then
            echo ""
            read_doc "$(sanitize_input "$remaining_args")"
        fi
        ;;
    hook-check)
        hook_check
        ;;
    uninstall)
        uninstall
        ;;
    whats-new|whats|what)
        shift
        remaining="$*"
        if [[ "$remaining" =~ new ]] || [[ "$FULL_ARGS" =~ what.*new ]]; then
            whats_new
        else
            read_doc "$(sanitize_input "$1")"
        fi
        ;;
    "")
        list_docs
        ;;
    *)
        if [[ "$FULL_ARGS" =~ what.*new ]]; then
            whats_new
        else
            read_doc "$(sanitize_input "$1")"
        fi
        ;;
esac

# Ensure script always exits successfully
exit 0